## **Developer Guide: Extending Functionality in `server2.js` Using `PluginManager`**

This guide explains how developers can extend the functionality of the `server2.js` application by leveraging the `PluginManager`. By using this system, you can add new features or customize existing behavior without altering the core codebase.

---

### **1. Understanding the PluginManager**

The `PluginManager` is designed to:
1. Dynamically load plugins from a specified directory.
2. Provide a standardized interface for plugins to:
   - Register routes.
   - Add middleware.
   - Perform initialization tasks.
3. Inject common dependencies (like a database connection, logger, or configuration) into plugins.

### **2. Plugin Structure**

Each plugin must follow a specific structure to be compatible with the `PluginManager`. Here is the template:

#### **Plugin Template**
```javascript
module.exports = {
    name: "pluginName", // Unique name for the plugin
    version: "1.0.0",   // Plugin version

    // Initialization logic
    initialize({ logger }) {
        logger.info(`${this.name} v${this.version} initialized`);
    },

    // Middleware registration
    registerMiddleware({ app, logger }) {
        app.use((req, res, next) => {
            logger.info(`[${this.name}] Middleware executed`);
            next();
        });
    },

    // Route registration
    registerRoutes({ app, db, logger }) {
        app.get('/plugin/example', async (req, res) => {
            logger.info(`[${this.name}] Handling /plugin/example`);
            res.json({ message: "Hello from pluginName!" });
        });
    }
};
```

---

### **3. Directory Structure**

Plugins are placed in a designated `plugins/` directory at the root of the project. Each plugin is a separate JavaScript file.

```
project/
├── server2.js
├── plugins/
│   ├── examplePlugin.js
│   ├── anotherPlugin.js
│   └── ...
├── dependencyManager.js
├── ...
```

---

### **4. How to Add a Plugin**

#### **Step 1: Create a New Plugin**
Add a new file in the `plugins/` directory. For example, create `plugins/examplePlugin.js`:

```javascript
module.exports = {
    name: "examplePlugin",
    version: "1.0.0",
    initialize({ logger }) {
        logger.info(`${this.name} initialized`);
    },
    registerMiddleware({ app, logger }) {
        app.use((req, res, next) => {
            logger.info(`[${this.name}] Middleware executed`);
            next();
        });
    },
    registerRoutes({ app, db, logger }) {
        app.get('/plugin/example', async (req, res) => {
            logger.info(`[${this.name}] Route accessed`);
            res.json({ message: "Hello from examplePlugin!" });
        });
    }
};
```

---

#### **Step 2: Start the Server**
Start the `server2.js` application. The `PluginManager` will automatically load all plugins from the `plugins/` directory and register their routes and middleware.

```bash
node server2.js
```

---

### **5. Example Plugin: Advanced Logging**

Suppose you want to add custom logging functionality. Here’s an example plugin:

#### **File: `plugins/advancedLogger.js`**
```javascript
module.exports = {
    name: "advancedLogger",
    version: "1.0.0",

    initialize({ logger }) {
        logger.info(`${this.name} initialized`);
    },

    registerMiddleware({ app, logger }) {
        app.use((req, res, next) => {
            const { method, url } = req;
            logger.info(`[${this.name}] ${method} ${url}`);
            next();
        });
    },

    registerRoutes({ app, logger }) {
        app.get('/plugin/logs', (req, res) => {
            logger.info(`[${this.name}] Log endpoint hit`);
            res.json({ message: "Advanced Logger Plugin Active!" });
        });
    }
};
```

#### **Output When Accessing `/plugin/logs`**
Logs generated by the middleware:
```
[advancedLogger] GET /plugin/logs
[advancedLogger] Log endpoint hit
```

---

### **6. Dependency Injection**

The `PluginManager` injects common dependencies into plugins to ensure seamless integration. Here are the available dependencies:

- **`app`**: The Express application instance.
- **`db`**: A function to get a database connection.
- **`logger`**: A logging utility (e.g., `console` or `winston`).

#### Example: Using Dependencies
```javascript
registerRoutes({ app, db, logger }) {
    app.get('/plugin/data', async (req, res) => {
        try {
            const connection = await db(); // Use injected DB connection
            const [results] = await connection.execute('SELECT * FROM my_table');
            res.json(results);
        } catch (error) {
            logger.error(`[examplePlugin] Error fetching data:`, error);
            res.status(500).json({ error: "Internal Server Error" });
        }
    });
}
```

---

### **7. Error Handling in Plugins**

Plugins should handle their errors gracefully to avoid breaking the server. The `PluginManager` wraps plugin execution in `try-catch` blocks.

#### Plugin Example with Error Handling
```javascript
registerRoutes({ app, logger }) {
    app.get('/plugin/errorExample', (req, res) => {
        try {
            throw new Error("Simulated Error");
        } catch (error) {
            logger.error(`[examplePlugin] Error occurred:`, error);
            res.status(500).json({ error: "Something went wrong!" });
        }
    });
}
```

---

### **8. PluginManager Code**

#### **PluginManager Implementation**
```javascript
class PluginManager {
    constructor(pluginDir, server, dependencyManager) {
        this.pluginDir = pluginDir;
        this.server = server;
        this.plugins = [];
        this.dependencyManager = dependencyManager;
    }

    loadPlugins() {
        const pluginFiles = fs.readdirSync(this.pluginDir).filter((file) => file.endsWith('.js'));

        pluginFiles.forEach((file) => {
            const pluginPath = path.join(this.pluginDir, file);
            try {
                const plugin = require(pluginPath);

                if (typeof plugin.initialize === 'function') {
                    const dependencies = this.dependencyManager.getDependencies();
                    plugin.initialize(dependencies);
                }

                this.plugins.push(plugin);
                console.log(`Plugin loaded: ${plugin.name} v${plugin.version}`);
            } catch (error) {
                console.error(`Failed to load plugin at ${pluginPath}:`, error.message);
            }
        });
    }

    registerPlugins(app) {
        this.plugins.forEach((plugin) => {
            try {
                const dependencies = this.dependencyManager.getDependencies();
                if (typeof plugin.registerMiddleware === 'function') {
                    plugin.registerMiddleware({ ...dependencies, app });
                }
                if (typeof plugin.registerRoutes === 'function') {
                    plugin.registerRoutes({ ...dependencies, app });
                }
            } catch (error) {
                console.error(`Error in plugin ${plugin.name}:`, error.message);
            }
        });
    }
}
```

---

### **9. Best Practices**

1. **Isolate Logic**: Avoid dependencies between plugins. Each plugin should be self-contained.
2. **Log Errors**: Use the `logger` dependency for consistent error reporting.
3. **Handle Errors Gracefully**: Always use `try-catch` in route handlers or middleware.
4. **Avoid Long-Running Tasks**: For heavy operations, consider background jobs or queues.

